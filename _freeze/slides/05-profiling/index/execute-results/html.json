{
  "hash": "9dbc8cecee8e575d7788fdfc3df5e4a5",
  "result": {
    "markdown": "---\ntitle: Profiling\nsubtitle: Advanced R\nauthor: \n  - name: Heather Turner and Ella Kaye\n  - name: Department of Statistics, University of Warwick\ntitle-slide-attributes:\n  data-background-color: \"#552D62\"\ndate: 2023-06-20\ndate-format: long\nformat: \n  warwickpres-revealjs:\n    execute:\n      echo: true\n      code-overflow: wrap\n---\n\n\n## Overview\n\n- Profiling\n- **profvis**\n\n# Profiling {.inverse}\n\n## Profiling code\n\nTo make our code more efficient, we first need to identify the bottlenecks, in \nterms of time and/or memory usage.\n\nProfiling stops the execution of code every few milliseconds and records \n\n - The call stack: the function currently being executed, the function that it \n was called from and so on up to the top-level function call.\n - The memory allocated and released since the last record.\n \nWe will use the **profvis** package to visualise profiling results.\n\n## Example: nested pause functions\n\nThe following code is saved in `profiling-example.R` and uses `profvis::pause()` \nto wait 0.1s inside each function\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntop_level <- function() {\n  profvis::pause(0.1)\n  middle_level()\n  bottom_level()\n}\nmiddle_level <- function() {\n  profvis::pause(0.1)\n  bottom_level()\n}\nbottom_level <- function() {\n  profvis::pause(0.1)\n}\n```\n:::\n\n\n::: {.notes}\n`Sys.sleep()` can not be used as it would not show in profiling output\n:::\n\n# profvis {.inverse}\n\n## Using profvis\n\nSource the code to be profiled and pass the function call to be profiled to \n`profvis()`\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(profvis)\nsource(\"profiling-example.R\")\nprofvis(top_level())\n```\n:::\n\n\nAn interactive HTML document will open with the results.\n\nIn RStudio this will open in the source pane; click \"show in new window\" button to open the document in a new window.\n\n## \n\n![Screenshot of the profvis HTML output. At the bottom, a stacked set of horizontal bars along a time axis, representing the length of time in each function. At a given time, the top-level function is at the bottom of the stack with each nested function stacked on top. The source code is shown at the top of the screenshot, with a horizontal bar for each line, showing the time spent. Interpretation on next slide](images/profiling-example.png)\n\n## Interpretation\n\nIn the *flame graph* the yellow bars correspond to lines in the source file shown above the graph. The plot is interactive.\n\nIn the overall time of 250ms we see:\n\n - 4 equal-sized blocks for each pause of 0.1s\n - Nearly all time is spent in the top-level function\n - Nearly half the time is spent in the mid-level function\n - Nearly half the time is also spent in the bottom-level function\n - The `cmp` function is called as R tries to compile new functions so that it can call the compiled version in subsequent calls.\n \nNo objects are created or deleted: no memory changes.\n\n## Data tab\n\nThe Data tab shows a table with the memory and time usage for each function call. The nested calls can be expanded/collapsed to show/hide the corresponding lines.\n\n![Screenshot of the data tab in the profvis HTML output. A table with columns \"Code\" (function name), \"File\" (name of source file containing function), \"Memory (MB)\" and \"Time (ms)\".](images/profiling-example-data-tab.png)\n\n## Memory profiling\n\nTo illustrate memory profiling we can consider a loop that concatenates values.\n\nAs it is a small code snippet, we can pass to `profvis()` directly\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprofvis({\n  x <- integer()\n  for (i in 1:10000) {\n    x <- c(x, i)\n  }\n})\n```\n:::\n\n\n## \n\n![Flame graph for profiling the contenation example. Interpretation on next slide.](images/profiling-memory.png)\n\n## `<GC>`\n\nAs expected, the majority of the time is spent within `c()`, but we also see a lot time spent in `<GC>`, the garbage collector.\n\nIn the memory column next to the corresponding line in the source code, we see a bar to left labelled -123.0 and a bar to the right labelled 137.2. This means that 137 MB of memory was allocated and 123 MB of memory was released.\n\nEach call to `c()` causes a new copy of `x` to be created.\n\nMemory profiling can help to identify short-lived objects that might be avoided by changes to the code.\n\n## Monopoly\n\n:::: {.columns}\n\n::: {.column width=\"70%\"}\nIn the game of Monopoly, players roll two die to move round the board. Players buy assets on which they can charge rent or taxes and aim to make the most money.\n\nThe squares on the board represent\n:::\n\n::: {.column width=\"30%\"}\n![](images/monopoly.jpg)\n:::\n\n::::\n\n\n\n\n- Properties, train stations or utility companies to buy\n- Events that trigger an action, e.g. paying a tax or going to jail\n\nThe **efficient** package contains the `simulate_monopoly()` function to simulate game play; we'll use this to practice profiling.\n\n## Your turn!\n\n1. Install the **efficient** package with the following code to keep the code source files:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nremotes::install_github(\"csgillespie/efficient\",\n                         INSTALL_opts = \"--with-keep.source\")\n```\n:::\n\n\n2. Use `profvis()` to profile `simulate_monopoly(10000)`. Explore the output. Which parts of the code are slow?\n\n3. Most of the time is spent in the function `move_square()`. Use `View(move_square)` to view the source code. Copy the code to a new  `.R file` and rename the function `move_square2`. Edit `move_square2()` to speed up the slow parts of the code. (Go to next slide for testing the updates)\n\n## Your turn! (continued)\n\nCreate a wrapper to run a specified move square function `n` times with different seeds:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrun <- function(n, fun){\n  x <- numeric(n)\n  for (i in seq_len(n)) {\n    set.seed(i)\n    x[i] <- fun(1)\n  }\n  x\n}\n```\n:::\n\nRun `bench::mark(run(n, move_square), run(n, move_square2))` with `n = 1000` to test your changes. \n\nFinally, compare `profvis(run(n, move_square))` with `profvis(run(n, move_square2))`.\n\n## General principles\n\n* Avoid optimizing too soon\n  - Get the code right first\n* Avoid over-optimization\n  - Focus on the bottlenecks\n  - Keep an eye on the units - will real gains be made?\n  - Think about maintainability: readability, simplicity, dependencies\n* Avoid anonymous functions\n  - Name utility functions to see them in the profile\n* Use benchmarking to assess alternative implementations\n\n## C++ and Rcpp\n\nIn the next session, we'll cover using C++ via **Rcpp** to rewrite R code that has been identified through profiling as causing bottlenecks in your code.\n\n# End matter {.inverse}\n\n## References\n\n- Wickham, H, _Advanced R_ (2nd edn), _Improving performance section_ \n\n  <https://adv-r.hadley.nz/perf-improve.html>\n\n- Gillespie, C and Lovelace, R, _Efficient R programming_\n \n  <https://csgillespie.github.io/efficientR/>\n\n\n## License\n\nLicensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License ([CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/){target=\"_blank\"}).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}