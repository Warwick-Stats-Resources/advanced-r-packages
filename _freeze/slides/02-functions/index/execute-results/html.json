{
  "hash": "6e39782c1d6005d513f646c43ecaa49e",
  "result": {
    "markdown": "---\ntitle: Functions\nsubtitle: Advanced R\nauthor: \n  - name: Heather Turner and Ella Kaye\n  - name: Department of Statistics, University of Warwick\ntitle-slide-attributes:\n  data-background-color: \"#552D62\"\ndate: 2023-06-19\ndate-format: long\nformat: \n  warwickpres-revealjs:\n    execute:\n      echo: true\n      code-overflow: wrap\n---\n\n\n## Overview\n\n- Functions basics\n- Beyond the basics\n- Error handling\n\n# Functions basics {.inverse}\n\n## Components of a function\n\nFunctions are defined by three components:\n\n - the name of the function\n - the arguments of the function, inside `( )`\n - the body of the function that computes the result, inside `{ }`\n \nThey are created using `function()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nt_statistic <- function(n) {\n    x <- rnorm(n)\n    y <- rnorm(n)\n    t.test(x, y)$statistic\n}\n```\n:::\n\n\n## Naming functions\n\nAs with arguments, function names are important:\n\n- use a name that describes what it returns (e.g. `t_statistic`) or what it does (e.g. `remove_na`)\n\n- try to use one convention for combining words (e.g. snake case `t_statistic` or camel case `tStatistic`)\n\n- avoid using the same name as other functions\n\n## Specified arguments\n\n*specified* arguments are those named in the function definition, e.g. \nin `rnorm()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nargs(rnorm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (n, mean = 0, sd = 1) \nNULL\n```\n:::\n:::\n\nthe arguments are `n`, `mean` and `sd`.\n\n`mean` and `sd` have been given default values in the function definition, but `n` has not, so the function fails if the user does not pass a value to `n`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrnorm()\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in rnorm(): argument \"n\" is missing, with no default\n```\n:::\n:::\n\n\n## Name and order of arguments\n\nThe user can pass objects to these arguments using their names or by supplying unnamed values in the right order\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrnorm(5, 1, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]   3.176854  -2.243561   8.284291 -21.530589   1.259725\n```\n:::\n\n```{.r .cell-code}\nrnorm(5, sd = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 16.709199 -6.822982 21.836873 11.941988 -8.928574\n```\n:::\n:::\n\n\nSo naming and order is important! Some guidelines\n\n- put compulsory arguments first, e.g. data\n- put rarely used arguments last, e.g. tolerance setting\n- use short but meaningful argument names\n- if relevant, use the same argument names as similar functions\n\n## Using arguments\n\nArguments are used as objects in the function code.\n\nA new environment is created each time the function is called, separate \nfrom the global workspace.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- 1\ny <- 3\nf <- function(x, y){\n    a <- 1\n    x <- x + a\n    x + y\n}\nf(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\na\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): object 'a' not found\n```\n:::\n:::\n\n\n## Return values (single)\n\nBy default, functions return the object created by the last line of code\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nf <- function(x) {\n    x <- x + 1\n    log(x)\n}\n```\n:::\n\n\nAlternatively `return()` can be used to terminate the function and return\na given object\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nf <- function(x) {\n    if (all(x > 0)) return(log(x))\n    x[x <= 0] <- 0.1\n    log(x)\n}\n```\n:::\n\n\n## Return values (multiple)\n\nMultiple objects can be returned in a list:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmean_and_sd <- function(x) {\n  res_mean <- mean(x, na.rm = TRUE)\n  res_sd <- sd(x)\n  \n  list(mean = res_mean,\n       sd = res_sd)\n}\n\nx <- 1:3\nmean_and_sd(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$mean\n[1] 2\n\n$sd\n[1] 1\n```\n:::\n:::\n\n\n## RStudio helper\n\nRStudio has a helper to turn code into a function:\n\n1. Select the lines of code that will become the body of the function.\n2. Select \"`Code`\" > \"`Extract Function`\" from the menu.\n3. Enter the name of the new function in the dialog box.\n4. Edit the arguments if required.\n5. Add/edit the last line to specify the return value.\n\n## Exercise files\n\n<https://github.com/Warwick-Stats-Resources/Advanced-R-exercises>\n\n- You can get the files by creating a new project from version control in RStudio (if set up)\n\n- By going to the 'Code' button in the repo, then 'Download ZIP', then opening Advanced-R-exercises.Rproj.\n\n## Exercise 1\n\nIn the `qq_norm` chunk of `exercises.Rmd` there is some code to compute the slope and intercept of the line to add to a quantile-quantile plot, comparing \nsample quantiles against theoretical quantiles of a N(0, 1) distribution.\n\nTurn this code into a function named `qq_norm` taking the sample data as an argument and returning the slope and intercept in a list.\n\nRun this chunk to source the function, then run the `normal-QQ` chunk which uses the `qq_norm` function to compute parameters for an example plot.\n\n# Beyond the basics {.inverse}\n\n## Function environment\n\nA new environment is created each time the function is called, separate \nfrom the global workspace.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- 1\ny <- 3\nf <- function(x, y){\n    a <- 1\n    x <- x + a\n    x + y\n}\nf(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\na\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): object 'a' not found\n```\n:::\n:::\n\n\n\n## Lexical scoping\n\nIf an object is not defined within the function, or passed in as an argument, R looks for it in the *parent environment* where the function was defined\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- 1\ny <- 3\nf <- function(x){\n    x + y\n}\nf(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nrm(y)\nf(x)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in f(x): object 'y' not found\n```\n:::\n:::\n\n\nIt is safest (and best practice) to use arguments rather than depend on global variables! \n\n## Unspecified arguments\n\n`...` or the *ellipsis* allow unspecified arguments to be passed to the function. \n\nThis device is used by functions that work with arbitrary numbers of objects, e.g. \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nargs(sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (..., na.rm = FALSE) \nNULL\n```\n:::\n\n```{.r .cell-code}\nsum(1, 4, 10, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 17\n```\n:::\n:::\n\n\nIt can also be used to pass on arguments to another function, e.g.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nt_statistic <- function(x, g, ...) {\n    t.test(x ~ g, ...)$stat\n}\n```\n:::\n\n\n## Using `...`\n\nArguments passed to `...` can be collected into a\nlist for further analysis\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmeans <- function(...){\n    dots <- list(...)\n    vapply(dots, mean, numeric(1), na.rm = TRUE)\n}\nx <- 1\ny <- 2:3\nmeans(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.0 2.5\n```\n:::\n:::\n\nSimilarly the objects could be concatenated using `c()`\n\n## Side effects\n\nA side-effect is a change outside the function that occurs when the\nfunction is run, e.g.\n\n- plot to the graphics window or other device\n- printing output to the console\n- write data to a file\n\nA function *can* have many side-effects and a return value, but it is \nbest practice to have a separate function for each task, e.g creating a plot or a table.\n\nWriting to file is usually best done outside a function.\n\n## Excercise 2\n\nCopy your `qq_norm` function to the `qq` chunk and rename it `qq`. \n\nAdd a new argument `qfun` to specify any quantile function (e.g. `qt`, `qf`, etc). Give it the default value `qnorm`. \n\nIn the body of `qq`, use `qfun` instead of `qnorm` to compute `q_theory`. Use `...` to pass on arguments to `qfun`.\n\nRun the `qq` chunk and test your function on the `t-QQ` chunk. \n\n\n## Using functions from other packages\n\nIn our own functions (outside of packages), it is possible to use `library`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nscale_rows <- function(X){\n    library(matrixStats)\n    X <- X - rowMeans(X)\n    X/rowSds(X)\n}\n```\n:::\n\n\nBut this loads the entire package, potentially leading to clashes with functions from other packages. It is better to use the **import** package:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nscale_rows <- function(X){\n    import::from(matrixStats, rowSds)\n    X <- X - rowMeans(X)\n    X/rowSds(X)\n}\nscale_rows(matrix(1:12, nrow = 3))\n```\n:::\n\n\n:::{.notes}\nThen in our script we don't need to use `library(matrixStats)` for \n`rowSds` to work (it must be installed though)!\n:::\n\n## Custom ggplot\n\n**ggplot2**, like **dplyr** and other tidyverse packages, uses \n*non-standard evaluation*, that is, it refers to variable names in a data frame as if they were objects in the current environment\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(mtcars, aes(x = mpg, y= disp)) +\n    geom_point()\n```\n:::\n\n\nTo emulate this, we have to need to **embrace** arguments\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggscatter <- function(data, x, y){\n    import::from(ggplot2, ggplot, aes, geom_point)\n    ggplot(data, aes(x = {{ x }}, y = {{ y }})) +\n        geom_point()\n}\nggscatter(mtcars, x = mpg, y = disp)\n```\n:::\n\n\n## Externalizing function code\n\nIt is a good idea to separate function code from analysis code.\n\nPut related functions together and source as required\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsource(\"modelFunctions.R\")\nsource(\"plotFunctions.R\")\n```\n:::\n\nThe **import** package enables only necessary, top-level functions to be imported to the global workspace:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nimport::here(poissonModel, quasiPoissonModel, .from = \"modelFunctions.R\")\n```\n:::\n\n\nIn either case, `import::from` commands can be put outside the function body to make the code easier to read.\n\n# Error handling {.inverse}\n\n## Sanity checks\n\nTo avoid mistakes, you may want to add some basic sanity checks\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlogit <- function(p){\n    stopifnot(p > 0 & p < 1)\n    log(p/(1 - p))\n}\nlogit(2)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in logit(2): p > 0 & p < 1 is not TRUE\n```\n:::\n\n```{.r .cell-code}\nlogit(0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\n## Error messages\n\nOften the R messages can be quite obscure\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nzap <- function(x) if (max(x) < 1e7) 0 else x\nx <- c(1, 2, NA)\nzap(x)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in if (max(x) < 1e+07) 0 else x: missing value where TRUE/FALSE needed\n```\n:::\n:::\n\n\nMore helpful error message can be implemented using `stop`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nzap <- function(x) {\n    if (any(is.na(x))) stop(\"missing values in x\\nare\", \n                            \" not allowed\")\n    if (max(x) < 1e7) 0 else x\n}\nzap(x)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in zap(x): missing values in x\nare not allowed\n```\n:::\n:::\n\n\n## Warning messages\n\nWarning messages should be given using `warning()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsafe_log2 <- function(x) {\n    if (any(x == 0)) {\n        x[x == 0] <- 0.1\n        warning(\"zeros replaced by 0.1\")\n    }\n    log(x, 2)\n}\nsafe_log2(0:1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -3.321928  0.000000\n```\n:::\n:::\n\n\nOther messages can be printed using `message()`.\n\n## Suppressing warnings\n\nIf a warning is expected, you may wish to suppress it\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlog(c(3, -1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.098612      NaN\n```\n:::\n\n```{.r .cell-code}\nx <- suppressWarnings(log(c(3, -1)))\n```\n:::\n\n\nAll warnings will be suppressed however!\n\nSimilarly `suppressMessages()` will suppress messages.\n\n## Catching errors/warnings\n\nThe [**purrr**](https://purrr.tidyverse.org) package has various functions to catch issues.\n\n`possibly()` lets you modify a function to return a specified value when there \nis an error\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlog(\"a\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in log(\"a\"): non-numeric argument to mathematical function\n```\n:::\n\n```{.r .cell-code}\nlibrary(purrr)\nposs_log <- possibly(log, otherwise = NA)\nposs_log(\"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n`safely()` works in a similar way but returns a list with elements `\"result\"` \nand `\"error\"`, so you can record the error message(s). \n\n`quietly()` lets you modify a function to return printed output, warnings and \nmessages along with the result.\n\n## `traceback()`\n\nWhen an unexpected error occurs, there are several ways to track down the source of the error, e.g. `traceback()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nf1 <- function(x){ f2(x) }\nf2 <- function(x){ x + qqqq }\nf1(10)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in f2(x): object 'qqqq' not found\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntraceback()\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n```\n2: f2(2) at #1\n1: f1(10)\n```\n:::\n:::\n\n\n## `traceback()` in RStudio\n\nIn RStudio, if `Debug > On Error >  Error Inspector` is checked and the \ntraceback has at least 3 calls, the option to show traceback is presented\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nf1 <- function(x){ f2(x) }\nf2 <- function(x){ f3(x) }\nf3 <- function(x){ x + qqqq }\nf1(10)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in f3(x): object 'qqqq' not found\n```\n:::\n:::\n\n\n![RStudio error inspector giving options to show traceback or rerun with debug](images/error_inspector.png)\n\n:::{.notes}\nNote here about the importance of separating tasks into smaller functions\n- easier to debug!\n:::\n\n## `debugonce()`\n\n`debugonce()` flags a function for debugging the next time it is called\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndebugonce(f2)\nf1(10)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in f3(x): object 'qqqq' not found\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n```\ndebugging in: f2(2)\ndebug at #1: {\n    x + qqqq\n}\nBrowse[2]> ls()\n[1] \"x\"\nBrowse[2]> Q\n```\n:::\n:::\n\n\nWhen in debug mode type `n` or <kbd title = \"enter\">&#8629;</kbd> to step \nto the next line and `c` to continue to the end of a loop or the end of the function.\n\n## Breakpoints\n\nStepping through a function line by line can be tedious. In RStudio we \ncan set custom breakpoints in the source pane\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\nSet breakpoint in RStudio\n![](images/set_breakpoint.png)\n:::\n\n::: {.column width=\"50%\"}\nSource the code\n![](images/debug_source.png)\n:::\n\n::::\n\n## Start debugging from breakpoints\n\n![](images/jump_to_breakpoint.png)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhere::here()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"/Users/ellakaye/Rprojs/mine/advanced-r-packages\"\n```\n:::\n:::\n\n\n\n:::{.notes}\n`n` is automatically printed, so the first prompt is at the breakpoint\n:::\n\n## RStudio's Rerun with Debug {.smaller90}\n\nThe `Rerun with Debug` option will rerun the command that created the \nerror and enter debug mode where the error occurred.\n\nGood points:\n\n - Easy to enter debug mode (when option shown)\n - Can click in Traceback pane to view objects at any point in the call stack\n \nBad points:\n\n - May have gone past source of error (use breakpoints instead)\n - May enter deeply nested function: use `recover()` to select an earlier \n entry point\n\nAlternatively use `options(error = recover)`, \nrun code to debug, then set `options(error = NULL)`.\n\n## Exercise 3 {.smaller80}\n\nOpen `debug_practice.R` and source the function `f()`.\n\nTry to run `f(10)` - there's an error! Use `traceback()` to see which function call generated the error, then fix the problem. \n\nRun `f(10)` again - there is another error! Can you fix this directly given the error message?\n\nTry running `f(1)` - is the result what you expected? Use `debugonce()` to set debugging on `f()` and re-run `f(1)`. Step through the function, printing each object as it is created to see what is happening.\n\nCan you think how to improve the function? See if you can modify the function to give a sensible result for any integer.\n\n\n# End Matter {background-color=\"#552D62\"}\n\n## Resources\n\n- Functions chapter from Advanced R, Hadley Wickham\n\n  <https://adv-r.hadley.nz/functions.html>\n\n- Debugging chapter from Advanced R, Hadley Wickham\n\n  <https://adv-r.hadley.nz/debugging.html>\n  \n- Debugging from the RStudio User Guide\n\n  <https://docs.posit.co/ide/user/ide/guide/code/debugging.html>\n\n## License\n\nLicensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License ([CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/){target=\"_blank\"}).\n\n# Documenting and testing {background-color=\"#552D62\"}\n\n## Documenting functions\n\nComments help to record what a function does\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# reorder x by grouping variable g\ngroupSort <- function(x, g) {\n    ord <- order(g) #indices for ascending order of g\n    x[ord]\n}\n```\n:::\n\nThe **docstring** package enables *roxygen* comments to be turned into a help file\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(docstring)\ngroupSort <- function(x, g) {\n    #' Reorder a Vector by a Grouping Variable\n    #'\n    #' @param x a vector\n    #' @param g a grouping variable\n    ord <- order(g) #indices for ascending order of g\n    x[ord]\n}\n```\n:::\n\n\n## View the help file as usual\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n?groupSort\n```\n:::\n\n\n![HTML documentation generated by docstring](images/docstring_help_file.png)\n\nFor fuller documentation, see the **docstring** vignette.\n\n**ADD LINK TO VIGNETTE**\n\n## roxygen\n\n**ADD A SLIDE WITH SOME RESOURCES ABOUT ROXYGEN**\n\n## Validation\n\nWhen developing a function, we will want to validate its output.\n\nA simple approach is to try different inputs\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlog_2 <- function(x){\n    log(x, 2)\n}\nlog_2(2^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nlog_2(2^0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\nDoing this each time we change the function becomes tedious to check and error-prone as we miss important tests.\n\n## Unit testing\n\nThe **testthat** packages allows us to create a test suite:\n\n**ADD LINK**\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncontext(\"log_2 works correctly\")\n\ntest_that(\"log_2 returns log to base 2\", {\n    expect_equal(log_2(2^3), 3)\n    expect_equal(log_2(2^0), 0)\n})\n\ntest_that(\"negative values give error\", {\n    expect_error(log_2(2^-1))\n})\n```\n:::\n\n\n## Running tests\n\nIf we save the tests in a file, e.g. `tests.R`, we can use `test_file()` to run and check all tests:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(testthat)\ntest_file(\"tests.R\")\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n```\n√ | OK F W S | Context\nx |  2 1     | log_2 works correctly\n--------------------------------------------------------------------------------\ntests.R:9: failure: negative values give error\n`log_2(2^-1)` did not throw an error.\n--------------------------------------------------------------------------------\n\n== Results =====================================================================\nOK:       2\nFailed:   1\nWarnings: 0\nSkipped:  0\n```\n:::\n:::\n\n\n## Your turn! {.smaller80}\n\nCopy the `qq` function to a new R script and save as `functions.R`. Add roxygen comments at the start of the function body to define a title and parameter documentation.\n\nRun the `documentation` chunk of `exercises.Rmd` to view your documentation.\n\nOpen the `tests.R` script. Using `expect_equal` add some tests for the following\n\n - a sample of 100,000 from N(0, 1) gives approximately slope 1, intercept 0\n - a sample of 100,000 from N(0, 1/2) gives approximately slope 2, intercept 0\n - sample of 100,000 from N(2, 1) gives approximately slope 1, intercept -2\n\nUse the `tol` argument in `expect_equal` to set a tolerance of 0.01.\n\nRun the `tests` chunk of `exercises.Rmd` to run your tests with `test_file`. Try changing the expected tolerance to get a test to fail.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}