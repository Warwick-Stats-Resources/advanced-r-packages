{
  "hash": "585202d9200083f5848a3779cc2fb2f8",
  "result": {
    "markdown": "---\ntitle: Classes and Methods\nsubtitle: Advanced R\nauthor: \n  - name: Heather Turner and Ella Kaye\n  - name: Department of Statistics, University of Warwick\ntitle-slide-attributes:\n  data-background-color: \"#552D62\"\ndate: 2023-06-19\ndate-format: long\nformat: \n  warwickpres-revealjs:\n    execute:\n      echo: true\n      code-overflow: wrap\n---\n\n\n\n\n\n## Overview\n\n- Object-oriented programming\n- S3\n- S4\n\n# Object-oriented programming {.inverse}\n\n## Object-oriented programming (OOP)\n\n**Generic** functions provide a unified interface to **methods** for \nobjects of a particular **class**, e.g.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsummary(penguins$species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Adelie Chinstrap    Gentoo \n      152        68       124 \n```\n:::\n\n```{.r .cell-code}\nsummary(penguins$flipper_length_mm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n    172     190     197     201     213     231       2 \n```\n:::\n:::\n\n\nHere, we use the same function, `summary()`, on objects of classes `factor` and `integer` and get different output for each.\n\n## Motivation for OOP\n\n`summary()` could contain several if-else statements, but \n \n - the code would become hard to follow\n - only the function authors (R Core) could add new implementations\n \n## What does OOP offer?\n\n - separates the code for different data types\n - avoids duplicating code by method inheritance from parent class(es) to child class (subclass)\n - makes it possible for external developers to add methods for new types of object\n    - this can be particularly useful when writing R packages\n\n\n## OOP Systems in R\n\nThere are 3 main OOP systems in use:\n\n:::{.smaller90}\n* **S3** \n  - Used in base R and most recommended/CRAN packages\n  - Use unless you have good reason not to\n* **S4**\n  - Used on Bioconductor\n  - Allow more complex relationships between classes and methods\n* **R6**\n  - More similar to OOP in other languages\n  - May prefer if S3 insufficient and not aiming for Bioconductor\n    \nA new OOP system, **S7**, is in [development](https://rconsortium.github.io/OOP-WG/) as a successor to **S3** and **S4**. \n:::\n\n:::{.notes}\nR6 v similar to Python OOP (also Java, C++)\nJulia not an OOP language, but does have concept of multiple dispatch\n- so maybe a bit more like S3 idea?\n:::\n\n# S3 {.inverse}\n\n## S3 objects\n\nAn S3 object has a `\"class\"` attribute:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nattr(penguins$species, \"class\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"factor\"\n```\n:::\n\n```{.r .cell-code}\nunique(penguins$species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Adelie    Gentoo    Chinstrap\nLevels: Adelie Chinstrap Gentoo\n```\n:::\n:::\n\n\n## S3 objects: the underlying object\n\nWith `unclass()` we obtain the underlying object, here an integer vector \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nspecies_no <- unclass(penguins$species)\nclass(species_no)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nunique(species_no)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 2\n```\n:::\n\n```{.r .cell-code}\nattributes(species_no)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$levels\n[1] \"Adelie\"    \"Chinstrap\" \"Gentoo\"   \n```\n:::\n:::\n\n\n## Creating an S3 object with `stucture()`\nYou can use `structure()` to define an S3 object with a class attribute:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndp <- 2\nstructure(list(pi = trunc(10^dp * pi)/10^dp, dp = dp),\n          class = \"pi_trunc\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$pi\n[1] 3.14\n\n$dp\n[1] 2\n\nattr(,\"class\")\n[1] \"pi_trunc\"\n```\n:::\n:::\n\n\nPotentially further attributes can be added at the same time, but typically we would use a list to return all the required values.\n\n## Creating an S3 object with `class()`\n\nAlternatively, we can add a class attribute using the `class()` helper function:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npi2dp <- list(pi = trunc(10^dp * pi)/10^dp, dp = dp)\nclass(pi2dp) <- \"pi_trunc\"\npi2dp\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$pi\n[1] 3.14\n\n$dp\n[1] 2\n\nattr(,\"class\")\n[1] \"pi_trunc\"\n```\n:::\n:::\n\n\n## S3 generic functions\n\nS3 generic functions are simple wrappers to `UseMethod()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprint\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, ...) \nUseMethod(\"print\")\n<bytecode: 0x145b6ce68>\n<environment: namespace:base>\n```\n:::\n:::\n\n\n## `useMethod()`\n\nThe `UseMethod()` function takes care of *method dispatch*: selecting the S3 method according to the class of the object passed as the first argument.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nclass(penguins$species[1:3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"factor\"\n```\n:::\n\n```{.r .cell-code}\nprint(penguins$species[1:3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Adelie Adelie Adelie\nLevels: Adelie Chinstrap Gentoo\n```\n:::\n:::\n\n\nHere `print()` dispatches to the method `print.factor()`.\n\n## Inheritance\n\nThe class of an S3 object can be a vector of classes\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfit <- glm(y ~ x, data = data.frame(y = 1:3, x = 4:6))\nclass(fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"glm\" \"lm\" \n```\n:::\n:::\n\nWe say `fit` is a `\"glm\"` object that _inherits_ from class `\"lm\"`.\n\nThe `inherits()` function can be used to test if an object inherits from a given class\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ninherits(fit, \"glm\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n## Method dispatch\n\nAn S3 object can have more than one class e.g.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nclass(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n:::\n\n`UseMethod()` works along the vector of classes (from the first class to the last), looks for a method for each class and dispatches to the first method it finds.\n\nIf no methods are defined for any of class, the default is used , e.g. `print.default()`.\n\nIf there is no default, an error is thrown.\n\n## S3 Methods\n\nSee the methods for a given S3 class\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# nls is nonlinear least squares\nmethods(class = \"nls\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] anova       coef        confint     deviance    df.residual fitted     \n [7] formula     logLik      nobs        predict     print       profile    \n[13] residuals   summary     vcov        weights    \nsee '?methods' for accessing help and source code\n```\n:::\n:::\n\n\nSee the methods for a given generic function\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmethods(\"coef\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] coef.aov*     coef.Arima*   coef.default* coef.listof*  coef.maov*   \n[6] coef.nls*    \nsee '?methods' for accessing help and source code\n```\n:::\n:::\n\n\nAsterisked methods are not exported.\n\n\n\n## View S3 methods\n\nS3 methods need not be in the same package as the generic.\n\nFind an unexported method with `getS3method()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngetS3method(\"coef\", \"default\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (object, complete = TRUE, ...) \n{\n    cf <- object$coefficients\n    if (complete) \n        cf\n    else cf[!is.na(cf)]\n}\n<bytecode: 0x1157fcfc8>\n<environment: namespace:stats>\n```\n:::\n:::\n\nIn code, call the generic, rather than calling the method directly.\n\n## Writing S3 Methods\n\nThe arguments of a new method should be a superset of the arguments of the generic\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nargs(print)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, ...) \nNULL\n```\n:::\n:::\n\n\nNew methods have the name format `generic.class`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprint.pi_trunc <- function(x, abbreviate = TRUE, ...){\n  dp_text <- ifelse(abbreviate, \"d.p.\", \"decimal places\")\n  cat(\"pi: \", x$pi, \" (\", x$dp, \" \", dp_text, \")\", sep = \"\")\n}\nprint(pi2dp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npi: 3.14 (2 d.p.)\n```\n:::\n:::\n\n\n## `NextMethod()`\n\nWe can explicitly call the next method that would be called by `UseMethod()` to reuse code whilst customising as required\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbody(t.data.frame)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{\n    x <- as.matrix(x)\n    NextMethod(\"t\")\n}\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbody(rep.factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{\n    y <- NextMethod()\n    structure(y, class = class(x), levels = levels(x))\n}\n```\n:::\n:::\n\n\nIt is possible to call `NextMethod()` with arguments but it is safer to recall the generic with new arguments in this case.\n\n:::{.notes}\nWe have seen that `UseMethod()` will dispatch to the method of the next class in the class vector if a method is not defined for the first class.\n:::\n\n## Implicit classes\n\n`is.object()` can be used to find out if an object has a class (S3/S4/R6)\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nis.object(factor(1:3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.object(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nAn object that does not have an explicit class has an implicit class that will be used for S3 method dispatch. The implicit class can be found with `.class2()`\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nM <- matrix(1:12, nrow = 4)\nattr(M, \"class\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\n.class2(M)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\"  \"array\"   \"integer\" \"numeric\"\n```\n:::\n:::\n\n\n:::{.notes}\n.class2 since R 4.0.0\n:::\n\n## Attributes\n:::{.smaller90}\nWe can take advantage of existing S3 methods by returning an object of a existing S3 class or an implicit class, using attributes to add custom information\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- matrix(c(1:5, 2*(1:5)), ncol = 2)\ncenter_x <- scale(x, scale = FALSE)\nclass(center_x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n\n```{.r .cell-code}\nsummary(center_x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       V1           V2    \n Min.   :-2   Min.   :-4  \n 1st Qu.:-1   1st Qu.:-2  \n Median : 0   Median : 0  \n Mean   : 0   Mean   : 0  \n 3rd Qu.: 1   3rd Qu.: 2  \n Max.   : 2   Max.   : 4  \n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nattr(center_x, \"scaled:center\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 6\n```\n:::\n:::\n\nThis can avoid the need to define new classes and methods, in simple cases.\n:::\n\n## Your turn (part 1)\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n1. Create a function to fit an ordinary least squares model given a response `y` and an explanatory variable `x`, that returns an object of a new class `\"ols\"`, that inherits from `\"lm\"`.\n2. Define a print method for your function that it works as follows:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(1)\nres <- ols(x = 1:3, y = rnorm(3))\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIntercept:  -0.217 \nSlope:  -0.1046 \n```\n:::\n:::\n\n\nNote: I have set `options(digits = 4)` to limit the number of digits printed by default throughout this presentation (default is 7).\n\n## Your turn (part 2)\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n3. Write a summary method for your `ols` class that uses `NextMethod()` to compute the usual `lm` summary, but return an object of class `\"summary.ols\"`. \n4. Write a print method for the `\"summary.ols\"` which works as follows:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsummary(res)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoefficients: \n            Estimate Std. Error t value Pr(>|t|)\n(Intercept)  -0.2170     1.1408 -0.1902   0.8804\nx            -0.1046     0.5281 -0.1980   0.8755\n\nResidual standard error:  0.7468 \nMultiple R-squared:  0.03774 \n```\n:::\n:::\n\n\n:::{.notes}\nwill get issues with inheriting e.g. add1 method\n:::\n\n\n# S4 {.inverse}\n\n## Overview of S4\n\nS4 methods\n\n - use specialised functions for creating classes, generics and methods\n - allow _multiple inheritance_: a class can have multiple parents\n - allow _multiple dispatch_: method selection based on the class of multiple objects\n \nThe **methods** package provides the functions required to use S4 classes and methods, so always load this package when using S4.\n\n:::{.notes}\nuse import instead\n:::\n\n## S4 Classes\n\nAn S4 class can be defined with `setClass()`, with at least two arguments\n\n - A **name**, by convention in `UpperCamelCase`.\n - A named character vector specifying the names and classes of the **slots** (fields). Using the pseudo class `ANY` allows a slot to accept any type of object.\n \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetClass(\"Person\", \n  slots = c(\n    name = \"character\", \n    date_of_birth = \"Date\",\n    date_of_death = \"Date\",\n    age_at_death = \"numeric\"\n  )\n)\n```\n:::\n\n\n## Creating a new instance\n\nA new instance of the S4 object can be created using `new()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nflorence <- new(\"Person\", \n                name = \"Florence Nightingale\",\n                date_of_birth = as.Date(\"1820-05-12\"),\n                date_of_death = as.Date(\"1910-08-13\"),\n                age_at_death = 90)\nstr(florence)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFormal class 'Person' [package \".GlobalEnv\"] with 4 slots\n  ..@ name         : chr \"Florence Nightingale\"\n  ..@ date_of_birth: Date[1:1], format: \"1820-05-12\"\n  ..@ date_of_death: Date[1:1], format: \"1910-08-13\"\n  ..@ age_at_death : num 90\n```\n:::\n:::\n\n\nNote that the second onwards argument names in `new` are the names in the vector passed to `slots()` when defining the class.\n\n## Examining S4 objects\n\nFind the type of S4 class\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nis.object(florence)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nisS4(florence)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n.class2(florence)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Person\"\n```\n:::\n:::\n\n\nExtract the value of a slot (use @)\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngetSlots(\"Person\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         name date_of_birth date_of_death  age_at_death \n  \"character\"        \"Date\"        \"Date\"     \"numeric\" \n```\n:::\n\n```{.r .cell-code}\nflorence@age_at_death # or slot(florence, \"age_at_death\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 90\n```\n:::\n:::\n\n\n:::{.notes}\nclass() will only show class itself, not classes it inherits from\n:::\n\n## Prototype\n\nThe `prototype` argument can be used to specify default values, enabling partial specification\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetClass(\"Person\", \n  slots = c(\n    name = \"character\", \n    date_of_birth = \"Date\",\n    date_of_death = \"Date\",\n    age_at_death = \"numeric\"\n  ),\n  prototype = list(\n    name = NA_character_, \n    date_of_birth = as.Date(NA),\n    date_of_death = as.Date(NA),\n    age_at_death = NA_real_\n  )\n)\n```\n:::\n\n\nBe sure to use `list()` not `c()` for `prototype` -- easy mistake to make!\n\n## `initialize()`\n\nAn `initialize()` method can be used for more control over initialization\n\n:::{.smaller90}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetMethod(\"initialize\", \"Person\", \n  function(.Object, ...) {\n    # initialize with default method \n    # (named arguments override defaults)\n    .Object <- callNextMethod(.Object, ...)\n    \n    # compute age at death if not specified\n    year <- function(x) as.numeric(format(x, \"%Y\"))\n    m_day <- function(x) as.numeric(format(x, \"%m%d\"))\n    \n    if (is.na(.Object@age_at_death)){\n      n_year <- year(.Object@date_of_death) - year(.Object@date_of_birth)\n      birthday <- m_day(.Object@date_of_death) >= m_day(.Object@date_of_birth)\n      .Object@age_at_death <- n_year - !birthday\n    }\n    .Object\n  })\n```\n:::\n\n:::\n\n## Creating a new S4 obect from an old one\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nflorence <- new(\"Person\", \n                name = \"Florence Nightingale\",\n                date_of_birth = as.Date(\"1820-05-12\"))\nstr(florence)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFormal class 'Person' [package \".GlobalEnv\"] with 4 slots\n  ..@ name         : chr \"Florence Nightingale\"\n  ..@ date_of_birth: Date[1:1], format: \"1820-05-12\"\n  ..@ date_of_death: Date[1:1], format: NA\n  ..@ age_at_death : num NA\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nflorence <- initialize(florence, \n                       date_of_death = as.Date(\"1910-08-13\")) \nstr(florence)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFormal class 'Person' [package \".GlobalEnv\"] with 4 slots\n  ..@ name         : chr \"Florence Nightingale\"\n  ..@ date_of_birth: Date[1:1], format: \"1820-05-12\"\n  ..@ date_of_death: Date[1:1], format: \"1910-08-13\"\n  ..@ age_at_death : num 90\n```\n:::\n:::\n\n\n## Inheritance\n\nThe `contains` argument to `setClass()` specifies a class or classes to inherit slots and behaviour from\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetClass(\"BanknoteCharacter\", \n  contains = \"Person\", \n  slots = c(\n    denomination = \"numeric\",\n    first_issue = \"Date\",\n    last_legal = \"Date\"\n  ),\n  prototype = list(\n    denomination = NA_real_,\n    first_issue = as.Date(NA),\n    last_legal = as.Date(NA)\n  )\n)\n```\n:::\n\n\n## New instance of subclass\n\nCreating a new instance of the subclass will fill in the slots of the superclass\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nseriesD_10GBP <- new(\"BanknoteCharacter\", \n                     name = \"Florence Nightingale\", \n                     date_of_birth = as.Date(\"1820-05-12\"), \n                     date_of_death = as.Date(\"1910-08-12\"))\nstr(seriesD_10GBP)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFormal class 'BanknoteCharacter' [package \".GlobalEnv\"] with 7 slots\n  ..@ denomination : num NA\n  ..@ first_issue  : Date[1:1], format: NA\n  ..@ last_legal   : Date[1:1], format: NA\n  ..@ name         : chr \"Florence Nightingale\"\n  ..@ date_of_birth: Date[1:1], format: \"1820-05-12\"\n  ..@ date_of_death: Date[1:1], format: \"1910-08-12\"\n  ..@ age_at_death : num 90\n```\n:::\n:::\n\n## Show defined S4 Class\n\nUse `showClass()` to show (print) an S4 Class\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nshowClass(\"Person\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nClass \"Person\" [in \".GlobalEnv\"]\n\nSlots:\n                                                              \nName:           name date_of_birth date_of_death  age_at_death\nClass:     character          Date          Date       numeric\n\nKnown Subclasses: \"BanknoteCharacter\"\n```\n:::\n:::\n\n\n## Helper function\n\nIf a user is to create these objects, define a helper function named by the class\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nPerson <- function(name = NA, date_of_birth = NA, date_of_death = NA) {\n  new(\"Person\", \n      name = as.character(name), \n      date_of_birth = as.Date(date_of_birth), \n      date_of_death = as.Date(date_of_death))\n}\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nada <- Person(\"Ada Lovelace\", \"1815-12-10\", \"1852-11-27\")\nstr(ada)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFormal class 'Person' [package \".GlobalEnv\"] with 4 slots\n  ..@ name         : chr \"Ada Lovelace\"\n  ..@ date_of_birth: Date[1:1], format: \"1815-12-10\"\n  ..@ date_of_death: Date[1:1], format: \"1852-11-27\"\n  ..@ age_at_death : num 36\n```\n:::\n:::\n\n\n\n::: {.notes}\nPut computation in the `initialize` method where possible, so that it can be reused by subclasses.\n:::\n\n\n## Validator function\n\nUse `setValidity()` to check constraints beyond data type, e.g. that all slots have the same length\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetValidity(\"Person\", function(object) {\n  len <- vapply(slotNames(\"Person\"), \n                function(x) length(slot(object, x)),\n                numeric(1))\n  if (!all(len == len[1])){\n    \"slots should all be the same length\"\n  } else {\n    TRUE\n  }\n})\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nPerson(name = c(\"Ada Lovelace\", \"Grace Hopper\"), \n       date_of_birth = \"1815-12-10\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in validObject(.Object): invalid class \"Person\" object: slots should all be the same length\n```\n:::\n:::\n\n\n## S4 generic functions\n\nS4 generic functions are (usually) a wrapper to `standardGeneric()`, e.g.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngetGeneric(\"kronecker\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstandardGeneric for \"kronecker\" defined from package \"base\"\n\nfunction (X, Y, FUN = \"*\", make.dimnames = FALSE, ...) \nstandardGeneric(\"kronecker\")\n<bytecode: 0x125479598>\n<environment: 0x12546c7e0>\nMethods may be defined for arguments: X, Y, FUN, make.dimnames\nUse  showMethods(kronecker)  for currently available ones.\n```\n:::\n:::\n\n\nBy default, all arguments apart from `...` are used for method dispatch.\n\n\n## Writing S4 generic functions\n\nUse `setGeneric` to define a new generic, with the optional `signature` argument to specify the arguments to use for method dispatch\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetGeneric(\"myGeneric\", \n  function(x, ..., verbose = TRUE) standardGeneric(\"myGeneric\"),\n  signature = \"x\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"myGeneric\"\n```\n:::\n:::\n\n\nDo not use `{}` in the function definition here.\n\nS4 generics use `lowerCamelCase` names by convention.\n\n## S4 Methods\n\nS4 methods for a generic function are defined with `setMethod()`, which takes three main arguments\n\n - The **name** of the generic function.\n - The **signature** specifying the classes for one or more of the arguments used  for method dispatch\n - The method, defined as a function with a superset of the arguments of the generic\n\n## Writing S4 Methods\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nargs(getGeneric(\"show\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (object) \nNULL\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetMethod(\"show\", \"Person\", function(object) {\n  cat(object@name, \"\\n\",\n      \"Born: \", format(object@date_of_birth, \"%d %B %Y\"), \"\\n\",\n      \"Died: \", format(object@date_of_death, \"%d %B %Y\"), \n                \" (aged \", object@age_at_death, \")\\n\",\n      sep = \"\")\n})\nflorence\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFlorence Nightingale\nBorn: 12 May 1820\nDied: 13 August 1910 (aged 90)\n```\n:::\n:::\n\n\n## Accessor generics\n\nIt is good practice to define generics to get and set slots that the user should have access to.\n\nFor example, a generic to get and set the date of birth\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetGeneric(\"dob\", function(x) standardGeneric(\"dob\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dob\"\n```\n:::\n\n```{.r .cell-code}\nsetGeneric(\"dob<-\", function(x, value) standardGeneric(\"dob<-\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dob<-\"\n```\n:::\n:::\n\n\n## Accessor methods\n\nMethods can then be defined for multiple classes using the same interface.\n\nAccess the date of birth from a Person object\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetMethod(\"dob\", \"Person\", function(x) x@date_of_birth)\ndob(florence)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1820-05-12\"\n```\n:::\n:::\n\n\nChange the date of birth\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetMethod(\"dob<-\", \"Person\", function(x, value) {\n  x@date_of_birth <- as.Date(value)\n  validObject(x)\n  x\n})\ndob(florence) <- \"1820-05-11\"\ndob(florence)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1820-05-11\"\n```\n:::\n:::\n\n\n## Method dispatch\n\n* One argument, single inheritance along vector of classes:\n    - Same as for S3\n* One argument, multiple inheritance:\n    - Follow all possible paths from child class to parent classes\n    - Dispatch to first method found with the shortest path\n* Multiple dispatch \n    - As multiple inheritance, but follow possible paths for multiple arguments\n    \nKeep it simple: dispatch on one or two arguments usually sufficient.\n\nAvoid ambiguous cases by defining methods earlier in path.\n\n## Pseudo-classes\n\nMethods can be defined for the `ANY` pseudo-class\n\n - Only selected if no method found for real classes\n \nThe `MISSING` pseudo-class is useful for dispatch on two arguments: allow different behaviour if only one argument specified.\n\n## Your turn\n\n:::{.smaller80}\n1. Create an S4 class `Diag` to represent a diagonal matrix with two slots:\n - `n` the number of rows/cols\n - `x` the numeric values of the diagonal elements\n    \n    Add a prototype to specify default values.\n2. Test your class by creating a new instance first without providing any values for the slots and then providing some example values.\n3. Create an `initialize` method so that the `n` slot is computed automatically and does not have to be provided.\n4. Create a `Diag()` helper function to create a new `Diag` object, with the user only having to specify the diagonal elements.\n5. Create a `show` method to state the size of the matrix and print the diagonal elements.\n:::\n\n# End matter {.inverse}\n\n## References\n\n- Main reference for this session, goes a bit further (including R6):\nWickham, H, _Advanced R_ (2nd edn), _Object-oriented programming section_, <https://adv-r.hadley.nz/oo.html>\n\n- Fun example creating `Turtle` and `TurtleWithPen` classes to create simple graphics by moving the turtle:\n<https://stuartlee.org/2019/07/09/s4-short-guide/> \n\n## License\n\nLicensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License ([CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/){target=\"_blank\"}).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}