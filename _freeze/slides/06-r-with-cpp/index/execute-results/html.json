{
  "hash": "01fdbb5d8b8aa54d6c551bd9a5af5f29",
  "result": {
    "markdown": "---\ntitle: C++ and Rcpp\nsubtitle: Advanced R\nauthor: \n  - name: Heather Turner and Ella Kaye\n  - name: Department of Statistics, University of Warwick\ntitle-slide-attributes:\n  data-background-color: \"#552D62\"\ndate: 2023-06-20\ndate-format: long\nformat: \n  warwickpres-revealjs:\n    execute:\n      echo: true\n      code-overflow: wrap\n---\n\n\n## Overview\n\n- When to use C++\n- Getting set up\n- C++ basics and Rcpp\n- Rcpp sugar\n\n# When to use C++ {.inverse}\n\n## Limits of R\n\nSometimes you reach the limits of R:\n\n  - Your code is still slow despite optimizing the computational approach and the R implementation\n  - You could speed up the R code, but it results in very obscure, convoluted code\n  \nIn this case it can make sense to code parts in C++.\n\n## Typical scenarios\n\nThere are some typical scenarios where C++ is likely to be a good idea\n\n- Loops that can't be vectorized because iterations depend on previous results\n- Recursive functions, or problems which involve calling functions millions of times.\n- Problems that require advanced data structures and algorithms that R doesn’t provide. \n\n::: {.notes}\nThe overhead of calling a function in C++ is much lower than in R.\n:::\n\n# Getting set up {.inverse}\n\n## Set up to use C++\n\nTo use C++, you need a working C++ compiler. \n\nOn MacOS/Windows there is some setup to do, but it will also set you up to\n\n - Develop packages in R\n - Install packages from GitHub that include  C/C++ code\n \nOn Linux, you will usually have a C++ compiler installed, but you might as well get set up to develop R packages too.\n\n::: {.notes}\nIf you’ve followed the development tools section of the course prerequisites, you should be fully set-up for this already.\n:::\n\n## Linux\n\nDebian/Ubuntu:\n\n```{.sh}\napt-get update\napt-get install r-base-dev\n```\n\nFedora/RedHat: should be set up already.\n\n## MacOS\n\nOption 1\n\n- [Register as an Apple developer (for free)](https://developer.apple.com/programs/register/)\n  - Then, in the terminal:\n  \n     ```{.sh}\n     xcode-select --install\n     ```\n\nOption 2 \n\n- Install the current release of full [Xcode from the Mac App Store](https://itunes.apple.com/ca/app/xcode/id497799835?mt=12)\n - Within XCode go to Preferences -> Downloads and install the Command Line Tools\n- More convenient but installs a lot you don't need\n\n## Windows\n\n- Download the Rtools installer that matches your version of R from <https://cran.r-project.org/bin/windows/Rtools/>\n- Run the installer, `Rtools.exe`, keeping the default settings.\n\n# C++ basics and Rcpp {.inverse}\n\n## A first C++ function\n\nConsider an R function `add_r()` to add two numbers\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nadd_r <- function(x, y) x + y\n```\n:::\n\n\nHere's how we might write an equivalent `add_cpp()` function in C++\n\n::: {.cell layout-align=\"center\"}\n\n```{.cpp .cell-code}\ndouble add_cpp(double x, double y) { \n  double value = x + y;\n  return value;\n}\n```\n:::\n\n\n- The type for the return value is declared first\n- The type of each argument must be declared\n- The type of intermediate objects must be declared\n- Return statements must use `return`\n\n## Rcpp\n\nTo use `add_cpp()` in R we need to compile the C++ code and construct an R function that connects to the compiled C++ function. \n\nThe R package **Rcpp** takes care of these steps for us. \n\nOne way is to use the `cppFunction()`, e.g.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(Rcpp)\ncppFunction('\n  double add_cpp(double x, double y) {\n    double value = x + y;\n    return value;\n  }\n')\n```\n:::\n\n\n## Using the C++ function\n\nAfter defining `add_cpp()` via `cppFunction()`, `add_cpp()` is available to use as a R function\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nadd_cpp\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, y) \n.Call(<pointer: 0x108908b40>, x, y)\n```\n:::\n\n```{.r .cell-code}\nadd_cpp(3, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n:::\n\n\n## Stand-alone C++ files\n\nIt is better to define functions in C++ files (extension `.cpp`). These files will be recognised by RStudio and other IDEs, with the usual benefits.\n\nThe C++ file should have these lines at the top:\n\n::: {.cell layout-align=\"center\"}\n\n```{.cpp .cell-code}\n#include <Rcpp.h>\nusing namespace Rcpp;\n```\n:::\n\n\n- The compiler will locate the Rcpp header file with functions and class definitions supplied by **Rcpp** and include the contents.\n- Adding the namespace means that we can use **Rcpp** functions in the C++ code without prefixing the function names by `Rcpp::`.\n \nAbove each function we want to use in R, add `// [[Rcpp::export]]`\n\n## Example C++ file\n\nThe following is in the file `add_cpp2.cpp`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.cpp .cell-code}\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble add_cpp2(double x, double y) {\n  double value = x + y;\n  return value;\n}\n```\n:::\n\n\n## `sourceCpp()`\n\nNow we can use `sourceCpp()` to make the C++ functions available in R\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npath <- here::here(\"C++\", \"add_cpp2.cpp\")\nsourceCpp(path)\nadd_cpp2(5, 9)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 14\n```\n:::\n:::\n\n\n## Benefits of separate C++ files\n\nThere are a number of benefits to writing C++ code in separate `.cpp` files, compared to `cppFunction()`\n\n- syntax highlighting\n- avoid mistakes switching from R to C code\n- line numbers for compilation errors\n- highlighting errors (e.g. missing \";\")\n\n## C++ Basics\n\n - Every statement within `{` `}` must be terminated by a `;`.\n - Use `=` for assignment (`<-` is not valid).\n - Addition, subtraction, multiplication and division use the same operators as R (`+`, `-`, `*`, `/`).\n - Comparison operators are the same as R (`==`, `!=`, `>`, etc)\n - One-line comments start with `//`.\n - Multi-line comments use `/*` `*/` delimiters\n \n```{.cpp}\n/*\nExample\nmulti-line comment\n*/\n```\n\n## Data types\n\nThe basic C++ data types are scalars. **Rcpp** provides vector versions\n<br>\n<br>\n\n| R         | C++ (scalar) | Rcpp (vector)   |\n|-----------|--------------|-----------------|\n| numeric   | double       | NumericVector   |\n| integer   | int          | IntegerVector   |\n| character | char         | CharacterVector |\n| logical   | bool         | LogicalVector   |\n<br>\n\n**Rcpp** also provides `String` as an alternative to `char`\n\n:::{.notes}\nCare needed with NA\ndouble: more bits used to represent a real number vs single precision\n - range 2^-(2^10) to 2^(2^10). vs same with 2^7\n - precision ~15 d.p. vs 7\n::: \n\n## Example: no inputs, scalar output\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.cpp .cell-code}\nint one() {\n  return 1;\n}\n```\n:::\n\n\n## Example: if/else (scalar input, scalar output)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.cpp .cell-code}\nint signC(int x) {\n  if (x > 0) {\n    return 1;\n  } else if (x == 0) {\n    return 0;\n  } else {\n    return -1;\n  }\n}\n```\n:::\n\n\n## For loop syntax\n\nA C++ `for` loop has the form\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.cpp .cell-code}\nfor (int i = 0; i < n; ++i) {\n  total += x[i];\n}\n```\n:::\n\n\n- Syntax: `for (initialisation; condition; increment)`\n    - Initialize integer `i` at zero\n    - Continue as long as `i` is less than `n`\n    - Increment `i` by 1 after each iteration \n      - `++i` is equivalent to `i = i + 1`\n- `total += x[i]` is equivalent to `total = total + x[i]`\n- **Vector indices start at zero**\n\n## Example: `for` loop (vector input, scalar output)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.cpp .cell-code}\ndouble sumC(NumericVector x) {\n  int n = x.size();\n  double total = 0;\n  for (int i = 0; i < n; ++i) {\n    total += x[i];\n  }\n  return total;\n}\n```\n:::\n\n\n- Use `.size()` method to find the length of a vector\n\n## Example: `while` loop (vector input, scalar output)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.cpp .cell-code}\ndouble sumC(NumericVector x) {\n  int n = x.size();\n  double total = 0;\n  int i = 0;\n  while (i < n) {\n    total += x[i];\n    ++i;\n  }\n  return total;\n}\n```\n:::\n\n\n- Use `break` to break from a while or for loop\n- Use `continue` to skip to the next iteration (vs `next` in R)\n\n## Example: vector output\n\nThe following computes Euclidean distances \n\n$$d_i  = \\sqrt{(x - y_i)^2}$$\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.cpp .cell-code}\nNumericVector distC(double x, NumericVector y) {\n  int n = y.size();\n  NumericVector dist(n);\n  for(int i = 0; i < n; ++i) {\n    dist[i] = sqrt(pow(ys[i] - x, 2.0));\n  }\n  return out;\n}\n```\n:::\n\n\n- `dist(n)` is used to create a numeric vector named `dist` of length `n`. \n- `v(n)` would create a vector named `v`.\n\n::: {.notes}\nThis is a contrived example to demonstrate Rcpp functionality. Mathematically, it's measuring the distance between a single point, x, on the Real line and (a vector of) several other single points on the line. Given its on the Real line, absolute value is sufficient for the Euclidean distance between points - don't need pow and sqrt, but good to show them  \n:::\n\n## C++ Functions\n\n`pow` is a standard C++ function for computing a value raised to a power. \n\nBoth `pow` and `sqrt` are functions from the `<cmath>` library, see e.g. [w3schools C++ math](https://www.w3schools.com/cpp/cpp_math.asp).\n\nTo use `<cmath>` functions in C++ code, we would normally need to include the `<cmath>` header in our `.cpp` file. However, **Rcpp** defines its own version of these functions, so we can use them with just the **Rcpp** header.\n\n## Creating a C++ file in RStudio\n\nFrom the menu bar:\n\n- Go to File > New File > C++ file\n- This template already incleas the headers required for Rcpp\n- Delete the extra content, apart from the comment `//[Rcpp::export]`\n\nYou can also create a C++ file from the new file drop-down in the Files pane, but this will be blank. \n\n## Your turn\n\n1. Create a new C++ file (recommend using the RStudio template)\n2. Convert the following R function that computes a weighted mean to C++\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwmean_r <- function(x, w){\n  n <- length(x)\n  total <- total_w <- 0\n  for (i in 1:n){\n    total <- total + x[i] * w[i]\n    total_w <- total_w + w[i]\n  }  \n  total/total_w\n}\n```\n:::\n\n3. Use `sourceCpp()` to source in your function. \n4. Use `bench::mark()` to compare `wmean_r()`, `wmean_cpp()` and the **stats** function `weighted.mean()`.\n\n\n\n\n\n## Missing values in C++ data types\n\nC++ data types do not handle `NA`s in input well\n\n- `int`: use a length 1 `IntegerVector` instead\n- `double`: `NA`s okay (converted to `NAN`)\n- `char`: use `String` instead\n- `bool`: `NA`s converted to `true`; use `int` instead\n\n## Missing values in Rcpp vectors\n\nRcpp vectors handle `NA`s in the corresponding type<br><br>\n\n| Rcpp (vector)     | NA           |\n|-------------------|--------------|\n| `NumericVector`   | `NA_REAL`    |\n| `IntegerVector`   | `NA_INTEGER` |\n| `CharacterVector` | `NA_STRING`  |\n| `LogicalVector`   | `NA_LOGICAL` |\n\n## Matrices\n\nEach vector type has a corresponding matrix equivalent: `NumericMatrix`, `IntegerMatrix`, `CharacterMatrix` and `LogicalMatrix`. \n\nCreate a matrix called named `m1`\n\n::: {.cell layout-align=\"center\"}\n\n```{.cpp .cell-code}\nNumericMatrix m1(10, 5);\n```\n:::\n\n\n- Subset with `()`, e.g. `m1(3, 2)` for the value in row 3, column 2.\n- The first element is `m1(0, 0)`.\n- Use `.nrow` and `.ncol` methods to get the number of rows and columns \n- Assign matrix elements as follows\n\n::: {.cell layout-align=\"center\"}\n\n```{.cpp .cell-code}\nm1(0, 0) = 1;\n```\n:::\n\n\n## Example: row sums (matrix input, vector output)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.cpp .cell-code}\nNumericVector rowSumsC(NumericMatrix x) {\n  int nrow = x.nrow(), ncol = x.ncol();\n  NumericVector out(nrow);\n  \n  for (int i = 0; i < nrow; i++) {\n    double total = 0;\n    for (int j = 0; j < ncol; j++) {\n      total += x(i, j);\n    }\n    out[i] = total;\n  }\n  return out;\n}\n```\n:::\n\n\n\n## Statistical distributions\n\nAs in R, **Rcpp** provides d/p/q/r functions for the density, distribution function, quantile function and random generation.\n- Functions in the `Rcpp::` namespace return a vector.\n- Functions in the `R::` namespace (also provided by the **Rcpp** R package) return a scalar\n\nFor example we can sample a single value from a $N(0, 1)$ distribution by extracting the first element from a vector\n```{.cpp}\nrgamma(1, 3, 1 / (y * y + 4))[0];\n```\nOr use the `R::rgamma()` function to sample a single value directly\n```{.cpp}\nR::rgamma(3, 1 / (y * y + 4))\n```\n\n## Your turn (part 1)\n\nIn a new C++ file, convert the following Gibbs sampler to C++\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngibbs_r <- function(N, thin) {\n  mat <- matrix(nrow = N, ncol = 2)\n  x <- y <- 0\n\n  for (i in 1:N) {\n    for (j in 1:thin) {\n      x <- rgamma(1, 3, y * y + 4)\n      y <- rnorm(1, 1 / (x + 1), 1 / sqrt(2 * (x + 1)))\n    }\n    mat[i, ] <- c(x, y)\n  }\n  mat\n}\n```\n:::\n\n\n\n\n\n\n## Your turn (part 2)\n\nCreate a wrapper function to set the seed as follows:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset_seed <- function(expr){\n  set.seed(1)\n  eval(expr)\n}\n```\n:::\n\n\nBenchmark your `gibbs_r()` and `gibbs_c()` functions with N = 100 and thin = 10, using your wrapper function to set the seed.\n\n# Rcpp sugar {.inverse}\n\n## Rcpp sugar\n\nRcpp provides some \"syntactic sugar\" to allow us to write C++ code that is more like R code.\n\nOne example is operating on rows or columns of matrices. So far we have seen how to update individual elements of a `NumericMatrix`. Rcpp lets us extract an update whole rows/columns, e.g.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.rcpp .cell-code}\nmat(i, _) = NumericVector::create(x,y);\n```\n:::\n\n\nA whole column would be extracted with `mat(_, j)`.\n\n## Vectorized functions\n\nThe vectorized random generation functions are another example of Rcpp sugar. \n\nRcpp provide many more vectorized functions, for example:\n\n- arithmetic operators (`+`, `-`, `*`, `\\`)\n- logical operators (`==`, `!`, `=<`)\n- arithmetic functions (`sqrt`, `pow`, ...)\n- statistical summaries (`mean`, `median`, )\n \nIn addition, Rcpp provides many R-like functions, such as `which_max` or `rowSums`, see [Unofficial API documentation](https://thecoatlessprofessor.com/programming/cpp/unofficial-rcpp-api-documentation/#sugar) for a full list.\n\n## Rcpp sugar: vectorized functions\n\nRecall our distance function from earlier:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.cpp .cell-code}\nNumericVector distC(double x, NumericVector y) {\n  int n = y.size();\n  NumericVector out(n);\n  for(int i = 0; i < n; ++i) {\n    out[i] = sqrt(pow(ys[i] - x, 2.0));\n  }\n  return out;\n}\n```\n:::\n\n\nWith Rcpp vectorization, we can simplify this to:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.cpp .cell-code}\nNumericVector dist_sugar(double x, NumericVector y) {\n  return sqrt(pow(x - y, 2));\n}\n```\n:::\n\n\n## Example: row maximums\n\nThis example combines row-indexing and a vectorized function, `max()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.cpp .cell-code}\nNumericVector row_max(NumericMatrix mat) {\n  int nrow = mat.nrow();\n  NumericVector max(nrow);\n  for (int i = 0; i < nrow; i++)\n    max[i] = max( m(i,_) );\n  return max;\n}\n```\n:::\n\n\n\n## Your turn\n\nThe following R function can be used to simulate the value of $\\pi$:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\napprox_pi_r <- function(N) {\n    x <- runif(N)\n    y <- runif(N)\n    d <- sqrt(x^2 + y^2)\n    return(4 * sum(d < 1.0) / N)\n}\n```\n:::\n\n\nConvert this to C++, taking advantage of the vectorized Rcpp functions.\n\n\n\n\n\n\n::: {.notes}\nThis function gets used in an exercise in the Rcpp packages session.  \n:::\n\n# End matter {.inverse}\n\n## References\n\n:::{.smaller80}\n- Similar scope to this module:\nGillespie, C and Lovelace, R, _Efficient R programming_, _Rcpp section_, <https://csgillespie.github.io/efficientR/performance.html#rcpp>\n\n- Going a bit further:\nWickham, H, _Advanced R_ (2nd edn), _Rewriting R code in C++ chapter_, <https://adv-r.hadley.nz/rcpp.html>\n\n- Not very polished, but broader coverage of Rcpp functionality:\nTsuda, M.E., _Rcpp for everyone_, <https://teuder.github.io/rcpp4everyone_en/300_Rmath.html>\n\n- The **Rcpp** vignettes, accessed via `browseVignettes(\"Rcpp\")` or [CRAN](https://CRAN.R-project.org/package=Rcpp)\n\n- The unofficial [Rcpp API documentation](https://thecoatlessprofessor.com/programming/cpp/unofficial-rcpp-api-documentation)\n\n- Case studies (optimising by improving R code and/or using C++)\n  - <https://robotwealth.com/optimising-the-rsims-package-for-fast-backtesting-in-r/>\n  - <https://gallery.rcpp.org/articles/bayesian-time-series-changepoint/>\n  - The [Rcpp Gallery](https://gallery.rcpp.org/) has all sorts of examples, many illustrating advanced features of Rcpp).\n:::\n\n## License\n\nLicensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License ([CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/){target=\"_blank\"}).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}