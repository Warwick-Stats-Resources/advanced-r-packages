{
  "hash": "1ac60213371aa04c12cc9cc214a54d6f",
  "result": {
    "markdown": "---\ntitle: Testing\nsubtitle: R Packages\nauthor: \n  - name: Heather Turner and Ella Kaye\n  - name: Department of Statistics, University of Warwick\ntitle-slide-attributes:\n  data-background-color: \"#552D62\"\ndate: 2023-06-21\ndate-format: long\nformat: \n  warwickpres-revealjs:\n    execute:\n      echo: true\n      code-overflow: wrap\n---\n\n\n## Overview\n\n- Unit testing with **testthat**\n- Test driven development\n\n# Unit testing with testthat {.inverse}\n\n## Why test?\n\nWe build new functions one bit at a time.\n\nWhat if a new thing we add changes the existing functionality?\n\nHow can we check and be sure all the old functionality still works with New Fancy Feature?\n\nUnit Tests!\n\n::: {.notes}\nGives confidence to package users as well  \n:::\n\n## Set up test infrastructure\n\nFrom the root of a package project:\n\n```r\nusethis::use_testthat()\n```\n\n```\nâœ” Adding 'testthat' to Suggests field in DESCRIPTION\nâœ” Setting Config/testthat/edition field in DESCRIPTION to '3'\nâœ” Creating 'tests/testthat/'\nâœ” Writing 'tests/testthat.R'\nâ€¢ Call `use_test()` to initialize a basic test file and open it for editing.\n```\n\n`tests/testthat.R` loads **testthat** and the package being tested, so you don't need to add `library()` calls to the test files.\n\n## Tests are organised in three layers\n\n![](images/test_organization.png){fig-align=\"center\"}\n\n::: {.notes}\nA file holds multiple related tests.\n\nA test groups together multiple expectations to test the output from a simple function, a range of possibilities for a single parameter from a more complicated function, or tightly related functionality from across multiple functions.\n\nAn expectation is the atom of testing. It describes the expected result of a computation: Does it have the right value and right class? \n:::\n\n## What to test\n\nTest every individual task the function completes separately.\n\nCheck both for successful situations and for expected failure situations.\n\n## Expectations\n\nThree expectations cover the vast majority of cases\n\n```r\nexpect_equal(object, expected)\n\nexpect_error(object, regexp = NULL, class = NULL)\n\nexpect_warning(object, regexp = NULL, class = NULL)\n```\n\n:::{.notes}\nIt used to be standard practice to test for errors and warnings using regexp, but that has downsides - it's not always clear why a test is failing. Testing via class is a more modern, safer approach, which we'll use below.\n:::\n\n## Our example function\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nanimal_sounds <- function(animal, sound) {\n  \n  if (!rlang::is_character(animal, 1)) {\n    cli::cli_abort(\"{.var animal} must be a single string!\")\n  }\n  \n  if (!rlang::is_character(sound, 1)) {\n    cli::cli_abort(\"{.var sound} must be a single string!\")\n  }\n  \n  paste0(\"The \", animal, \" goes \", sound, \"!\")\n}\n```\n:::\n\n\n## A sample test\n\nFirst, create a test file for this function, in either way:\n\n```{.r}\n# In RStudio, with `animal_sounds.R` the active file:\nusethis::use_test()  \n\n# More generally\nusethis::use_test(\"animal_sounds\")\n```\n\n. . .\n\n:::{.callout-note}\nRStudio makes it really easy to swap between associated R scripts and tests.\n\nIf the R file is open, `usethis::use_test()` (with no arguments) opens or creates the test.\n\nWith the test file open, `usethis::use_r()` (with no arguments) opens or creates the R script.\n:::\n\n## Add a test\n\nIn the now-created and open `tests/testthat/test-animal_sounds.R` script:\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntest_that(\"animal_sounds produces expected strings\", {\n  dog_woof <- animal_sounds(\"dog\", \"woof\")\n  expect_equal(dog_woof, \n               \"The dog goes woof!\")\n})\n```\n:::\n\n\n## Run tests \n\nTests can be run interactively like any other R code. The output will appear in the console, e.g. for a successful test:\n\n```\nTest passed ðŸ˜€\n```\n\nAlternatively, we can run tests in the background with the output appearing in the build pane.\n\n - `testthat::test_file()` -- run all tests in a file ('Run Tests' button)\n - `devtools::test()` -- run all tests in a package (Ctrl/Cmd + Shift + T, or Build > Test Package)\n\n## Testing equality\n\nFor numeric values, `expect_equal()` allows some tolerance:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nexpect_equal(10, 10 + 1e-7)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nexpect_equal(10, 10 + 1e-4, tolerance = 1e-4)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nexpect_equal(10, 10 + 1e-5)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: 10 not equal to 10 + 1e-05.\n1/1 mismatches\n[1] 10 - 10 == -1e-05\n```\n:::\n:::\n\n\nNote that when the expectation is met, there is nothing printed.\n\n. . . \n\nUse `expect_identical()` to test exact equivalence.\n\nUse `expect_equal(ignore_attr = TRUE)` to ignore different attributes (e.g. names).\n\n## `expect_error()`, `expect_warning()`\n\nWhen we expect an error/warning when the code is run, we need to pass the call \nto `expect_error()`/`expect_warning()` directly. \n\nOne way is to expect a text outcome using a regular expression:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntest_that(\"handles invalid inputs\", {\n    expect_error(animal_sounds(\"dog\", c(\"woof\", \"bow wow wow\")), \n                 \"`sound` must be a single string\")\n})\n```\n:::\n\n\nHowever, the `regexp` can get fiddly, especially if there are characters to escape. There is a more modern, precise way...\n\n::: {.notes}\nhave to call `animal_sounds` within `expect_error` - if we try calling it first (as we did in `expect_equal`) our code will throw an error before it has a chance to test for it!  \n:::\n\n## Using a condition `class`\n\nWhen using `cli::cli_abort()` and `cli::cli_warn()` to throw errors and warnings, we can signal the condition with a `class`, which we can then use in our tests.\n\nFirst, we need to modify the calls to `cli::cli_abort` in `animal_sounds()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nif (!rlang::is_character(sound, 1)) {\n  cli::cli_abort(\n    c(\"{.var sound} must be a single string!\",\n      \"i\" = \"It was {.type {sound}} of length {length(sound)} instead.\"),\n    class = \"error_not_single_string\"\n  )\n}\n\n# and same for `animal` argument\n```\n:::\n\n\n## Using a condition's class in tests\n\nWe can then check for this class in the test\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntest_that(\"handles invalid inputs\", {\n    expect_error(animal_sounds(\"dog\", c(\"woof\", \"bow wow wow\")), \n                 class = \"error_not_single_string\") \n})\n```\n:::\n\n\nAdvantages of using `class`:\n\n- It is under your control\n- If the condition originates from base R or another package, proceed with caution -- a good reminder to re-consider the wisdom of testing a condition that is not fully under your control in the first place.\n\n[From <https://r-pkgs.org/testing-basics.html#testing-errors>]{.smaller80}\n\n::: {.notes}\nNeed to use argument name `class` as not matched by position (regexp comes before first)  \n:::\n\n## Your turn\n\n1. Create a test file for `animal_sounds()` and add the tests defined in the \nslides.\n2. Add a new expectation to the test \"handles invalid inputs\" to test the \nexpected behaviour when a factor of length 1 is passed as the `sound` argument.\n3. Run the updated test by sending the code chunk to the console.\n4. Run all the tests.\n5. Commit your changes to the repo.\n\n::: {.notes}\nanimal_sounds(factor(\"cat\"), \"miaow\")) \n:::\n\n## Snapshot tests\n\nSometimes it is difficult to define the expected output, e.g. to test images or \noutput printed to the console. `expect_snapshot()` captures all messages, warnings, errors, and output from code.\n\nWhen we expect the code to throw an error (e.g. if we want to test the appearance of an informative message), we need to specify `error = TRUE`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntest_that(\"error message for invalid input\", {\n  expect_snapshot(animal_sounds(\"dog\", c(\"woof\", \"bow wow wow\")),\n                  error = TRUE)\n})\n```\n:::\n\n\nSnapshot tests can not be run interactively by sending to the console, instead \nwe must use `devtools::test()` or `testthat::testfile()`.\n\n::: {.notes}\nexpect_error for testing that an error is thrown, expect_snapshot for testing the appearance of the error message\n\nsnapshot test skipped on CRAN by default - use other functions to test correctness where possible.\n\nEquivalently Build menu \"Test Package\" or RStudio code editor \"Run tests\" button\n:::\n\n## Create snapshot\n\nRun the tests once to create the snapshot\n\n```\nâ”€â”€ Warning (test-animal_sounds.R:16:3): error message for invalid input â”€â”€\nAdding new snapshot:\nCode\n  animal_sounds(\"dog\", c(\"woof\", \"bow wow wow\"))\nError <error_not_single_string>\n  `sound` must be a single string!\n  i It was a character vector of length 2 instead.\n```\n\nAn `animal_sounds.md` file is created in `tests/testhat/_snaps` with the code \nand output.\n\n## Test against a snapshot\n\n:::{.smaller90}\nNext time the tests are run the output will be compared against this snapshot.\n\nSuppose we update some of the error message in `animal_sounds` to\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n\"{.var sound} must be a {.cls character} vector of length 1!\"\n```\n:::\n\n\nWhen we rerun the test, we'll get a failure:\n\n```\nâ”€â”€ Failure (test-animal_sounds.R:16:3): error message for invalid input â”€â”€\nSnapshot of code has changed:\nold vs new\n  \"Code\"\n  \"  animal_sounds(\\\"dog\\\", c(\\\"woof\\\", \\\"bow wow wow\\\"))\"\n  \"Error <error_not_single_string>\"\n- \"  `sound` must be a single string!\"\n+ \"  `sound` must be a <character> vector of length 1!\"\n  \"  i It was a character vector of length 2 instead.\"\n\n* Run testthat::snapshot_accept('animal_sounds') to accept the change.\n* Run testthat::snapshot_review('animal_sounds') to interactively review the change.\n```\n:::\n\n::: {.notes}\nNote the next steps with snapshot_accept and snapshot_review  \n:::\n\n# Test driven development {.inverse}\n\n## So far we've done this\n\n![](images/dev_cycle_before_testing.png){fig-align=\"center\"}\n\n## Test driven development is a new workflow\n\n![](images/dev_cycle_with_testing.png){fig-align=\"center\"}\n\n## Your turn\n\n1. Make this test pass\n\n   ```r\n   giraffe <- animalSounds(\"giraffe\")\n   expect_equal(giraffe, \n                \"The giraffe makes no sound.\")\n   ```\n   Hint: set the default value for the sound argument to `NULL`.\n2. Commit your changes to the git repo.\n3. Push your commits from this session.\n\n## When you stop work, leave a test failing. {.inverse .center .center-h}\n\n# End matter {.inverse}\n\n## References\n\nWickham, H and Bryan, J, _R Packages_ (2nd edn, in progress), <https://r-pkgs.org>.\n\nR Core Team, _Writing R Extensions_, <https://cran.r-project.org/doc/manuals/r-release/R-exts.html>\n\n## License\n\nLicensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License ([CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/){target=\"_blank\"}).\n\n\n```{=html}\n<!-- needs to be last chunk of presentation otherwise creates an extra slide -->\n<!-- requires Quarto v1.3 -->\n<!-- tint80 for border, tint20 for title -->\n<!-- this should hopefully no longer be necessary in Quarto 1.4 -->\n<!-- https://github.com/quarto-dev/quarto-cli/issues/5038 -->\n<style type=\"text/css\">\ndiv.callout-note {\n  border-left-color: #336695 !important;\n}\n\ndiv.callout-note.callout-style-default .callout-title {\n  background-color: #CCD9E4 !important;\n}\n\ndiv.callout-caution {\n  border-left-color: #AE4240 !important;\n}\n\ndiv.callout-caution.callout-style-default .callout-title {\n  background-color: #ebd0cf !important;\n}\n\ndiv.callout-tip {\n  border-left-color: #618157 !important;\n}\n\ndiv.callout-tip.callout-style-default .callout-title {\n  background-color: #d8e0d5 !important;\n}\n\ndiv.callout-important {\n  border-left-color: #775781 !important;\n}\n\ndiv.callout-important.callout-style-default .callout-title {\n  background-color: #ddd5e0 !important;\n}\n\ndiv.callout-warning {\n  border-left-color: #956133 !important;\n}\n\ndiv.callout-warning.callout-style-default .callout-title {\n  background-color: #e4d8cc !important;\n}\n</style>\n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}