# from https://stackoverflow.com/questions/40530968/overwriting-namespace-and-rd-with-roxygen2
# Cause of the problem.
# The roxygen2 package depends on the digest package. The error (The specified file is not readable) is generated by the digest function of the digest package, at the moment when this function calls the file.access function: https://github.com/eddelbuettel/digest/blob/master/R/digest.R#L102.
#
# I get:
#
#   > file.access("U:/Data", 4)
# U:/Data
# -1
# That means that U:/Data has not the read permission. But this is not true: it has the read permission. The problem is that my U: drive is a "network drive", and there are some issues with the file.access function for network drives, as we can see here for example: https://github.com/eddelbuettel/digest/issues/13.
#
# A workaround
# The problem would be solved if R.utils::fileAccess would be used instead of file.access in the digest::digest function.
#
# So, firstly take the code of the digest::digest function and modify it as follows.

mydigest <- function (object, algo = c("md5", "sha1", "crc32", "sha256",
                                       "sha512", "xxhash32", "xxhash64", "murmur32"), serialize = TRUE,
                      file = FALSE, length = Inf, skip = "auto", ascii = FALSE,
                      raw = FALSE, seed = 0, errormode = c("stop", "warn", "silent"))
{
  file.access <- R.utils::fileAccess
  function (object, algo = c("md5", "sha1", "crc32",
                             "sha256", "sha512", "xxhash32", "xxhash64",
                             "murmur32", "spookyhash"), serialize = TRUE,
            file = FALSE, length = Inf, skip = "auto", ascii = FALSE,
            raw = FALSE, seed = 0, errormode = c("stop", "warn",
                                                 "silent"), serializeVersion = .getSerializeVersion())
  {
    algo <- match.arg(algo)
    errormode <- match.arg(errormode)
    if (is.infinite(length)) {
      length <- -1
    }
    if (is.character(file) && missing(object)) {
      object <- file
      file <- TRUE
    }
    streaming_algos <- c("spookyhash")
    non_streaming_algos <- c("md5", "sha1", "crc32",
                             "sha256", "sha512", "xxhash32", "xxhash64",
                             "murmur32")
    if (algo %in% streaming_algos && !serialize) {
      .errorhandler(paste0(algo, " algorithm is not available without serialization."),
                    mode = errormode)
    }
    if (serialize && !file) {
      if (algo %in% non_streaming_algos) {
        object <- if ("nosharing" %in% names(formals(base::serialize)))
          base::serialize(object, connection = NULL, ascii = ascii,
                          nosharing = TRUE, version = serializeVersion)
        else base::serialize(object, connection = NULL, ascii = ascii,
                             version = serializeVersion)
      }
      if (any(!is.na(pmatch(skip, "auto"))))
        skip <- set_skip(object, ascii)
    }
    else if (!is.character(object) && !inherits(object, "raw") &&
             algo %in% non_streaming_algos) {
      return(.errorhandler(paste("Argument object must be of type character",
                                 "or raw vector if serialize is FALSE"), mode = errormode))
    }
    if (file && !is.character(object))
      return(.errorhandler("file=TRUE can only be used with a character object",
                           mode = errormode))
    if (file && algo %in% streaming_algos)
      return(.errorhandler(paste0(algo, " algorithm can not be used with files."),
                           mode = errormode))
    algoint <- algo_int(algo)
    if (file) {
      algoint <- algoint + 100
      object <- enc2utf8(path.expand(object))
      check_file(object, errormode)
    }
    if (is.character(skip))
      skip <- 0
    if (algo %in% non_streaming_algos) {
      val <- .Call(digest_impl, object, as.integer(algoint),
                   as.integer(length), as.integer(skip), as.integer(raw),
                   as.integer(seed))
    }
    else if (algo == "spookyhash") {
      val <- paste(.Call(spookydigest_impl, object, skip, 0,
                         0, serializeVersion), collapse = "")
    }
    if ((algoint == 3 || algoint == 103) && .getCRC32PreferOldOutput()) {
      val <- sub("^0+", "", val)
    }
    return(val)
  }
}
# Then do:

library(digest)
R.utils::reassignInPackage("digest", "digest", mydigest)
# And now the documentation can be updated by doing:

roxygen2::roxygenize()
